<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Enhanced Milk Overflow Detector</title>
  <style>
    body { 
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      font-family: sans-serif; 
      margin: 0; 
      padding: 20px; 
      background: #f5f5f5;
    }
    
    .video-container {
      position: relative;
      width: 90%;
      max-width: 400px;
      margin-bottom: 20px;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
    }
    
    video { 
      width: 100%; 
      height: auto;
      display: block;
      transform-origin: center center;
      transition: transform 0.3s ease;
    }
    
    .zoom-overlay {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 12px;
    }
    
    .target-zone {
      position: absolute;
      border: 2px dashed #ff4444;
      background: rgba(255, 68, 68, 0.1);
      pointer-events: none;
      display: none;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    button { 
      padding: 10px 20px; 
      font-size: 14px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #007bff;
      color: white;
      transition: background 0.3s;
    }
    
    button:hover { background: #0056b3; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    
    .zoom-controls {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    
    input[type="range"] {
      width: 100px;
    }
    
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 5px;
      text-align: center;
      font-weight: bold;
    }
    
    .status.loading { background: #fff3cd; color: #856404; }
    .status.ready { background: #d4edda; color: #155724; }
    .status.monitoring { background: #cce5ff; color: #004085; }
    .status.alert { background: #f8d7da; color: #721c24; }
    
    .detection-info {
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      margin-top: 10px;
      width: 90%;
      max-width: 400px;
    }
    
    .confidence-bar {
      width: 100%;
      height: 20px;
      background: #eee;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    
    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, #28a745, #ffc107, #dc3545);
      border-radius: 10px;
      transition: width 0.3s ease;
      width: 0%;
    }
  </style>
</head>
<body>
  <h1>ðŸ¥› Enhanced Milk Overflow Detector</h1>
  
  <div class="status loading" id="status">Loading ML Model...</div>
  
  <div class="video-container">
    <video id="video" autoplay playsinline muted></video>
    <div class="zoom-overlay" id="zoomLevel">Zoom: 1.0x</div>
    <div class="target-zone" id="targetZone"></div>
  </div>
  
  <div class="controls">
    <button id="startBtn" disabled>Start Monitoring</button>
    <button id="setTargetBtn">Set Target Zone</button>
    <button id="resetZoomBtn">Reset Zoom</button>
  </div>
  
  <div class="zoom-controls">
    <label for="zoomSlider">Zoom:</label>
    <input type="range" id="zoomSlider" min="1" max="3" step="0.1" value="1">
    <span id="zoomValue">1.0x</span>
  </div>
  
  <div class="detection-info">
    <div><strong>Detection Status:</strong> <span id="detectionStatus">Standby</span></div>
    <div><strong>Overflow Risk:</strong> <span id="riskLevel">Low</span></div>
    <div>Confidence: <span id="confidenceText">0%</span></div>
    <div class="confidence-bar">
      <div class="confidence-fill" id="confidenceFill"></div>
    </div>
  </div>

  <audio id="alarm" preload="auto">
    <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmMcBT2O2fPNeSsFJHfH8N2QQAoUXrTp66hVFA==" type="audio/wav">
  </audio>

  <!-- Load TensorFlow.js and COCO-SSD model -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow-models/4.3.0/coco-ssd/dist/coco-ssd.min.js"></script>

  <script>
    // Global variables
    let video, model, monitoring = false;
    let zoomLevel = 1.0;
    let targetZone = null;
    let isSettingTarget = false;
    
    // UI elements
    const statusEl = document.getElementById('status');
    const startBtn = document.getElementById('startBtn');
    const setTargetBtn = document.getElementById('setTargetBtn');
    const resetZoomBtn = document.getElementById('resetZoomBtn');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomValue = document.getElementById('zoomValue');
    const zoomLevelEl = document.getElementById('zoomLevel');
    const targetZoneEl = document.getElementById('targetZone');
    const detectionStatusEl = document.getElementById('detectionStatus');
    const riskLevelEl = document.getElementById('riskLevel');
    const confidenceTextEl = document.getElementById('confidenceText');
    const confidenceFillEl = document.getElementById('confidenceFill');
    const alarm = document.getElementById('alarm');

    // Initialize the application
    async function init() {
      video = document.getElementById('video');
      
      try {
        await startCamera();
        await loadModel();
        setupEventListeners();
        updateStatus('ready', 'Ready to monitor');
        startBtn.disabled = false;
      } catch (error) {
        updateStatus('alert', 'Failed to initialize: ' + error.message);
        console.error('Initialization error:', error);
      }
    }

    async function startCamera() {
      if (!navigator.mediaDevices?.getUserMedia) {
        throw new Error('Camera API not supported on this device/browser.');
      }

      try {
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            facingMode: "environment",
            width: { ideal: 640 },
            height: { ideal: 480 }
          } 
        });
        video.srcObject = stream;
        
        // Wait for video to be ready
        return new Promise((resolve) => {
          video.onloadedmetadata = () => {
            video.play();
            resolve();
          };
        });
      } catch (err) {
        throw new Error('Camera access required: ' + err.message);
      }
    }

    async function loadModel() {
      try {
        updateStatus('loading', 'Loading AI model...');
        model = await cocoSsd.load();
        console.log('COCO-SSD model loaded successfully');
      } catch (error) {
        throw new Error('Failed to load ML model: ' + error.message);
      }
    }

    function setupEventListeners() {
      // Zoom controls
      zoomSlider.addEventListener('input', (e) => {
        zoomLevel = parseFloat(e.target.value);
        updateZoom();
      });

      resetZoomBtn.addEventListener('click', () => {
        zoomLevel = 1.0;
        zoomSlider.value = 1.0;
        updateZoom();
      });

      // Target zone setting
      setTargetBtn.addEventListener('click', () => {
        isSettingTarget = !isSettingTarget;
        setTargetBtn.textContent = isSettingTarget ? 'Cancel Target' : 'Set Target Zone';
        setTargetBtn.style.background = isSettingTarget ? '#dc3545' : '#007bff';
        
        if (isSettingTarget) {
          video.style.cursor = 'crosshair';
          updateStatus('ready', 'Click and drag to set target zone');
        } else {
          video.style.cursor = 'default';
          updateStatus('ready', 'Ready to monitor');
        }
      });

      // Target zone selection
      let startX, startY, isDrawing = false;
      
      video.addEventListener('mousedown', (e) => {
        if (!isSettingTarget) return;
        
        const rect = video.getBoundingClientRect();
        startX = e.clientX - rect.left;
        startY = e.clientY - rect.top;
        isDrawing = true;
        
        targetZoneEl.style.left = startX + 'px';
        targetZoneEl.style.top = startY + 'px';
        targetZoneEl.style.width = '0px';
        targetZoneEl.style.height = '0px';
        targetZoneEl.style.display = 'block';
      });

      video.addEventListener('mousemove', (e) => {
        if (!isSettingTarget || !isDrawing) return;
        
        const rect = video.getBoundingClientRect();
        const currentX = e.clientX - rect.left;
        const currentY = e.clientY - rect.top;
        
        const width = Math.abs(currentX - startX);
        const height = Math.abs(currentY - startY);
        const left = Math.min(startX, currentX);
        const top = Math.min(startY, currentY);
        
        targetZoneEl.style.left = left + 'px';
        targetZoneEl.style.top = top + 'px';
        targetZoneEl.style.width = width + 'px';
        targetZoneEl.style.height = height + 'px';
      });

      video.addEventListener('mouseup', (e) => {
        if (!isSettingTarget || !isDrawing) return;
        
        const rect = video.getBoundingClientRect();
        const endX = e.clientX - rect.left;
        const endY = e.clientY - rect.top;
        
        // Store target zone coordinates (normalized to video dimensions)
        targetZone = {
          x: Math.min(startX, endX) / rect.width,
          y: Math.min(startY, endY) / rect.height,
          width: Math.abs(endX - startX) / rect.width,
          height: Math.abs(endY - startY) / rect.height
        };
        
        isDrawing = false;
        isSettingTarget = false;
        setTargetBtn.textContent = 'Set Target Zone';
        setTargetBtn.style.background = '#007bff';
        video.style.cursor = 'default';
        
        updateStatus('ready', 'Target zone set! Ready to monitor');
      });

      // Start monitoring
      startBtn.addEventListener('click', () => {
        if (!monitoring) {
          monitoring = true;
          startBtn.textContent = 'Stop Monitoring';
          startBtn.style.background = '#dc3545';
          updateStatus('monitoring', 'Monitoring for milk overflow...');
          monitorFrame();
        } else {
          monitoring = false;
          startBtn.textContent = 'Start Monitoring';
          startBtn.style.background = '#007bff';
          updateStatus('ready', 'Monitoring stopped');
          updateDetectionInfo('Standby', 'Low', 0);
        }
      });
    }

    function updateZoom() {
      video.style.transform = `scale(${zoomLevel})`;
      zoomValue.textContent = `${zoomLevel.toFixed(1)}x`;
      zoomLevelEl.textContent = `Zoom: ${zoomLevel.toFixed(1)}x`;
    }

    function updateStatus(type, message) {
      statusEl.className = `status ${type}`;
      statusEl.textContent = message;
    }

    function updateDetectionInfo(status, risk, confidence) {
      detectionStatusEl.textContent = status;
      riskLevelEl.textContent = risk;
      confidenceTextEl.textContent = `${Math.round(confidence * 100)}%`;
      confidenceFillEl.style.width = `${confidence * 100}%`;
      
      // Update risk level color
      if (risk === 'High') {
        riskLevelEl.style.color = '#dc3545';
      } else if (risk === 'Medium') {
        riskLevelEl.style.color = '#ffc107';
      } else {
        riskLevelEl.style.color = '#28a745';
      }
    }

    async function monitorFrame() {
      if (!monitoring || !model) return;

      try {
        // Run object detection
        const predictions = await model.detect(video);
        
        // Analyze predictions for milk/liquid overflow risk
        let maxRisk = 0;
        let detectionFound = false;
        
        for (const prediction of predictions) {
          // Look for objects that might indicate overflow (cups, bowls, bottles, etc.)
          const relevantClasses = ['cup', 'bowl', 'bottle', 'person'];
          
          if (relevantClasses.includes(prediction.class) && prediction.score > 0.3) {
            detectionFound = true;
            
            // Check if detection is in target zone (if set)
            if (targetZone) {
              const detectionCenter = {
                x: (prediction.bbox[0] + prediction.bbox[2] / 2) / video.videoWidth,
                y: (prediction.bbox[1] + prediction.bbox[3] / 2) / video.videoHeight
              };
              
              // Check if detection center is within target zone
              if (detectionCenter.x >= targetZone.x && 
                  detectionCenter.x <= targetZone.x + targetZone.width &&
                  detectionCenter.y >= targetZone.y && 
                  detectionCenter.y <= targetZone.y + targetZone.height) {
                
                // Simulate overflow risk based on position and confidence
                const riskScore = prediction.score * (1 + Math.random() * 0.3);
                maxRisk = Math.max(maxRisk, riskScore);
              }
            } else {
              // If no target zone, use general detection
              maxRisk = Math.max(maxRisk, prediction.score);
            }
          }
        }

        // Additional brightness analysis for foam detection
        const brightnessRisk = await analyzeBrightness();
        const combinedRisk = Math.max(maxRisk, brightnessRisk * 0.7);

        // Update UI based on risk level
        let status = 'Monitoring';
        let risk = 'Low';
        
        if (combinedRisk > 0.7) {
          status = 'HIGH RISK DETECTED!';
          risk = 'High';
          updateStatus('alert', 'âš ï¸ MILK OVERFLOW IMMINENT!');
          triggerAlarm();
        } else if (combinedRisk > 0.4) {
          status = 'Potential Risk';
          risk = 'Medium';
          updateStatus('monitoring', 'Monitoring - Elevated risk detected');
        } else if (detectionFound) {
          status = 'Object Detected';
          risk = 'Low';
          updateStatus('monitoring', 'Monitoring - Objects detected');
        }

        updateDetectionInfo(status, risk, combinedRisk);

      } catch (error) {
        console.error('Detection error:', error);
        updateDetectionInfo('Error', 'Unknown', 0);
      }

      // Continue monitoring
      if (monitoring) {
        setTimeout(() => requestAnimationFrame(monitorFrame), 500); // Check every 500ms
      }
    }

    async function analyzeBrightness() {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = video.videoWidth || 640;
      canvas.height = video.videoHeight || 480;

      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = frame.data;

      let brightPixels = 0;
      const totalPixels = frame.width * frame.height;

      // Analyze brightness in target zone if set
      if (targetZone) {
        const startX = Math.floor(targetZone.x * frame.width);
        const startY = Math.floor(targetZone.y * frame.height);
        const endX = Math.floor((targetZone.x + targetZone.width) * frame.width);
        const endY = Math.floor((targetZone.y + targetZone.height) * frame.height);
        
        for (let y = startY; y < endY; y++) {
          for (let x = startX; x < endX; x++) {
            const idx = (y * frame.width + x) * 4;
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            if (brightness > 200) brightPixels++;
          }
        }
        
        const zonePixels = (endX - startX) * (endY - startY);
        return (brightPixels / zonePixels) * 2; // Boost sensitivity in target zone
      } else {
        // Analyze entire frame
        for (let i = 0; i < data.length; i += 4) {
          const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
          if (brightness > 200) brightPixels++;
        }
        
        return brightPixels / totalPixels;
      }
    }

    function triggerAlarm() {
      // Play alarm sound
      alarm.play().catch(e => console.log('Audio play failed:', e));
      
      // Visual alert
      document.body.style.backgroundColor = '#ffebee';
      setTimeout(() => {
        document.body.style.backgroundColor = '#f5f5f5';
      }, 1000);
      
      // Vibration if supported
      if ('vibrate' in navigator) {
        navigator.vibrate([200, 100, 200, 100, 200]);
      }
      
      // Stop monitoring after alert
      setTimeout(() => {
        if (monitoring) {
          monitoring = false;
          startBtn.textContent = 'Start Monitoring';
          startBtn.style.background = '#007bff';
          updateStatus('alert', 'Alert triggered! Monitoring stopped.');
        }
      }, 2000);
    }

    // Initialize the application when page loads
    window.addEventListener('load', init);
  </script>
</body>
</html>